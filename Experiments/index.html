<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TerraMind: Deep Earth Observation</title>
    <!-- Three.js Core -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Three.js OrbitControls (Required for rotation/zoom) -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <!-- GSAP for smooth animations -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <style>
        /* --- CSS RESET & LAYOUT --- */
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #020205;
            font-family: 'Inter', 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            color: white;
        }

        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            outline: none;
            cursor: grab;
        }
        #canvas-container:active {
            cursor: grabbing;
        }

        /* --- UI OVERLAY --- */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 30px;
            box-sizing: border-box;
        }

        header {
            pointer-events: auto;
            max-width: 500px;
            background: radial-gradient(circle at center, rgba(0,0,0,0.5) 0%, rgba(0,0,0,0) 70%);
        }

        h1 {
            font-size: 3rem;
            font-weight: 300;
            letter-spacing: -0.02em;
            margin: 0;
            background: linear-gradient(135deg, #ffffff 0%, #a5f3fc 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 30px rgba(165, 243, 252, 0.3);
        }

        .subtitle {
            font-size: 1rem;
            color: #94a3b8;
            margin-top: 5px;
            font-weight: 400;
            letter-spacing: 0.05em;
            text-transform: uppercase;
        }

        /* Info Panel (Bottom Right) */
        #info-panel {
            align-self: flex-end;
            width: 320px;
            background: rgba(15, 23, 42, 0.75);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-left: 4px solid #22d3ee;
            padding: 20px;
            border-radius: 4px;
            transform: translateX(50px);
            opacity: 0;
            transition: all 0.4s cubic-bezier(0.16, 1, 0.3, 1);
            pointer-events: auto;
            margin-bottom: 40px; /* Lifted up slightly */
        }

        #info-panel.active {
            transform: translateX(0);
            opacity: 1;
        }

        .panel-header {
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: #22d3ee;
            margin-bottom: 5px;
        }

        .panel-title {
            font-size: 1.3rem;
            margin: 0 0 8px 0;
            font-weight: 600;
        }

        .panel-desc {
            font-size: 0.9rem;
            line-height: 1.5;
            color: #cbd5e1;
        }

        /* Instructions */
        #instructions {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.8rem;
            color: rgba(255, 255, 255, 0.5);
            letter-spacing: 0.15em;
            text-transform: uppercase;
            pointer-events: none;
            text-align: center;
            width: 100%;
            text-shadow: 0 2px 4px rgba(0,0,0,0.8);
        }

        /* Visual Indicators */
        #processing-indicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 2rem;
            font-weight: 100;
            color: #fff;
            opacity: 0;
            pointer-events: none;
            letter-spacing: 0.5em;
            text-shadow: 0 0 20px rgba(255,255,255,0.5);
            white-space: nowrap;
        }

    </style>
</head>
<body>

    <div id="ui-layer">
        <header>
            <h1>TerraMind</h1>
            <div class="subtitle">Any-to-Any Generative Earth Model</div>
        </header>

        <div id="info-panel">
            <div class="panel-header" id="panel-type">Modality</div>
            <h3 class="panel-title" id="panel-title">Select Data</h3>
            <div class="panel-desc" id="panel-desc">Hover to identify data types. Click to trigger the generative engine.</div>
        </div>
    </div>

    <div id="instructions">Left Click + Drag to Rotate • Scroll to Zoom • Right Click to Pan</div>
    <div id="processing-indicator">GENERATING...</div>
    <div id="canvas-container"></div>

<script>
    /**
     * TERRAMIND INTERACTIVE VISUALIZER (v2 Fixed)
     * Features: OrbitControls, Fixed Zoom, Stable Interaction
     */

    // --- DATA CONFIG ---
    const MODALITIES = [
        {
            name: "Optical (Sentinel-2)",
            type: "PASSIVE SENSOR",
            color: 0x00f2fe,
            desc: "Standard RGB and Infrared imagery. TerraMind uses this to understand surface texture and color, but it is blocked by clouds."
        },
        {
            name: "Radar (Sentinel-1)",
            type: "ACTIVE SENSOR",
            color: 0xff0055,
            desc: "SAR creates images by bouncing radio waves. It sees through clouds and night. TerraMind can 'dream' optical colors from this raw data."
        },
        {
            name: "Elevation (DEM)",
            type: "TOPOGRAPHY",
            color: 0x44ff44,
            desc: "3D height maps. TerraMind understands terrain shape, essential for predicting water flow and flood risks."
        },
        {
            name: "Land Use (LULC)",
            type: "CLASSIFICATION",
            color: 0xffaa00,
            desc: "Semantic maps labeling pixels as 'Urban', 'Forest', or 'Water'. The model can generate these maps instantly."
        },
        {
            name: "Vegetation (NDVI)",
            type: "ANALYTIC",
            color: 0xaa00ff,
            desc: "A calculated index showing plant health. TerraMind predicts crop yield or drought stress via this layer."
        },
        {
            name: "Geo-Text",
            type: "LANGUAGE",
            color: 0xffffff,
            desc: "Natural language + coordinates. Allows queries like 'Show me flooded areas in this region'."
        }
    ];

    // --- SCENE SETUP ---
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x020205, 0.02);

    const container = document.getElementById('canvas-container');
    const camera = new THREE.PerspectiveCamera(45, container.clientWidth / container.clientHeight, 0.1, 1000);
    // MOVED CAMERA FURTHER BACK for better initial visibility
    camera.position.set(0, 6, 22);

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(container.clientWidth, container.clientHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    container.appendChild(renderer.domElement);

    // --- CONTROLS (NEW) ---
    // Enables Rotate, Zoom, Pan
    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true; // Smooth motion
    controls.dampingFactor = 0.05;
    controls.minDistance = 10;
    controls.maxDistance = 40;
    controls.target.set(0, 0, 0);

    // --- LIGHTING ---
    const ambientLight = new THREE.AmbientLight(0x404040, 3);
    scene.add(ambientLight);

    const sunLight = new THREE.DirectionalLight(0xffffff, 1.5);
    sunLight.position.set(10, 10, 10);
    scene.add(sunLight);

    const rimLight = new THREE.PointLight(0x00f2fe, 2, 50);
    rimLight.position.set(-10, 0, 10);
    scene.add(rimLight);

    // --- OBJECTS ---

    // 1. Digital Earth
    const earthGroup = new THREE.Group();
    scene.add(earthGroup);

    // Black Core (occluder)
    const earthBlack = new THREE.Mesh(
        new THREE.IcosahedronGeometry(3.8, 2),
        new THREE.MeshBasicMaterial({ color: 0x000000 })
    );
    earthGroup.add(earthBlack);

    // Wireframe
    const earthWire = new THREE.Mesh(
        new THREE.IcosahedronGeometry(4, 3),
        new THREE.MeshBasicMaterial({
            color: 0x334455,
            wireframe: true,
            transparent: true,
            opacity: 0.15,
            blending: THREE.AdditiveBlending
        })
    );
    earthGroup.add(earthWire);

    // Particles
    const pGeo = new THREE.BufferGeometry();
    const pCount = 1800;
    const pPos = new Float32Array(pCount * 3);
    for(let i = 0; i < pCount * 3; i+=3) {
        const r = 4.1 + Math.random() * 0.2;
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos(2 * Math.random() - 1);
        pPos[i] = r * Math.sin(phi) * Math.cos(theta);
        pPos[i+1] = r * Math.sin(phi) * Math.sin(theta);
        pPos[i+2] = r * Math.cos(phi);
    }
    pGeo.setAttribute('position', new THREE.BufferAttribute(pPos, 3));
    const earthParticles = new THREE.Points(
        pGeo,
        new THREE.PointsMaterial({ size: 0.05, color: 0x22d3ee, transparent: true, opacity: 0.7 })
    );
    earthGroup.add(earthParticles);

    // 2. Stars
    const starGeo = new THREE.BufferGeometry();
    const starPos = new Float32Array(1500 * 3);
    for(let i=0; i<1500*3; i++) starPos[i] = (Math.random() - 0.5) * 150;
    starGeo.setAttribute('position', new THREE.BufferAttribute(starPos, 3));
    const starField = new THREE.Points(
        starGeo,
        new THREE.PointsMaterial({ color: 0xffffff, size: 0.08, opacity: 0.3, transparent: true })
    );
    scene.add(starField);

    // 3. Modality Plates
    const plateGroup = new THREE.Group();
    scene.add(plateGroup);
    const plates = [];
    const orbitRadius = 9.0; // Slightly wider orbit

    MODALITIES.forEach((mod, i) => {
        const angle = (i / MODALITIES.length) * Math.PI * 2;
        const x = Math.cos(angle) * orbitRadius;
        const z = Math.sin(angle) * orbitRadius;

        const wrapper = new THREE.Group();
        wrapper.position.set(x, 0, z);

        // Create Visuals
        const geo = new THREE.BoxGeometry(2.2, 1.5, 0.05);
        const mat = new THREE.MeshPhysicalMaterial({
            color: 0x101010, metalness: 0.9, roughness: 0.1, transmission: 0.2,
            transparent: true, opacity: 0.8
        });
        const mesh = new THREE.Mesh(geo, mat);

        // Glow Border
        const border = new THREE.LineSegments(
            new THREE.EdgesGeometry(geo),
            new THREE.LineBasicMaterial({ color: mod.color, transparent: true, opacity: 0.5 })
        );
        mesh.add(border);

        // Label
        const canvas = document.createElement('canvas');
        canvas.width = 512; canvas.height = 256;
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = 'rgba(0,0,0,0)'; ctx.fillRect(0,0,512,256);
        ctx.font = 'bold 50px Arial'; ctx.fillStyle = '#ffffff';
        ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
        ctx.fillText(mod.name.split(' ')[0], 256, 100);
        ctx.font = '30px Arial'; ctx.fillStyle = '#cccccc';
        if(mod.name.split(' ')[1]) ctx.fillText(mod.name.split(' ').slice(1).join(' '), 256, 160);

        const label = new THREE.Mesh(
            new THREE.PlaneGeometry(2, 1),
            new THREE.MeshBasicMaterial({ map: new THREE.CanvasTexture(canvas), transparent: true, side: THREE.DoubleSide })
        );
        label.position.z = 0.06;
        mesh.add(label);

        wrapper.add(mesh);
        mesh.userData = { id: i, data: mod, parentGroup: wrapper };
        plateGroup.add(wrapper);
        plates.push(mesh);
    });

    // 4. Connection Beam
    const beamGeo = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0,0,0), new THREE.Vector3(0,0,0)]);
    const beamMat = new THREE.LineBasicMaterial({ color: 0xffffff, opacity: 0, transparent: true, linewidth: 2 });
    const activeBeam = new THREE.Line(beamGeo, beamMat);
    scene.add(activeBeam);


    // --- LOGIC & INTERACTION ---
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    let hoveredObj = null;
    let isAnimating = false;

    window.addEventListener('mousemove', (event) => {
        const rect = renderer.domElement.getBoundingClientRect();
        mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
    });

    // Only trigger click if we haven't dragged the camera (simple check)
    let isDragging = false;
    window.addEventListener('mousedown', () => { isDragging = false; });
    window.addEventListener('mousemove', () => { isDragging = true; }); // Crude but works for orbit controls

    // Better drag detection
    let mouseDownPos = { x:0, y:0 };
    window.addEventListener('mousedown', (e) => { mouseDownPos = { x: e.clientX, y: e.clientY }; isDragging=false; });
    window.addEventListener('mouseup', (e) => {
        const dx = e.clientX - mouseDownPos.x;
        const dy = e.clientY - mouseDownPos.y;
        if(Math.abs(dx) < 5 && Math.abs(dy) < 5) {
            // It was a click, not a drag
            if(hoveredObj && !isAnimating) triggerGeneration(hoveredObj);
        }
    });


    function updateRaycaster() {
        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(plates);

        if (intersects.length > 0) {
            const obj = intersects[0].object;
            if (hoveredObj !== obj) {
                hoveredObj = obj;
                document.body.style.cursor = 'pointer';

                // Hover Effect
                gsap.to(obj.scale, { x: 1.15, y: 1.15, z: 1.15, duration: 0.3 });
                obj.children[0].material.color.setHex(0xffffff); // Highlight border white
                obj.children[0].material.opacity = 1;

                if (!isAnimating) updatePanel(obj.userData.data);
            }
        } else {
            if (hoveredObj) {
                // Reset Effect
                gsap.to(hoveredObj.scale, { x: 1, y: 1, z: 1, duration: 0.3 });
                // Use original color for border
                hoveredObj.children[0].material.color.setHex(hoveredObj.userData.data.color);
                hoveredObj.children[0].material.opacity = 0.5;

                hoveredObj = null;
                document.body.style.cursor = 'grab';
            }
        }
    }

    function updatePanel(data) {
        const panel = document.getElementById('info-panel');
        document.getElementById('panel-type').innerText = data.type;
        document.getElementById('panel-title').innerText = data.name;
        document.getElementById('panel-desc').innerText = data.desc;
        document.getElementById('panel-type').style.color = '#' + data.color.toString(16);
        panel.classList.add('active');
    }

    function triggerGeneration(sourceObj) {
        isAnimating = true;
        const sourceData = sourceObj.userData.data;

        let potentialTargets = plates.filter(p => p !== sourceObj);
        let targetObj = potentialTargets[Math.floor(Math.random() * potentialTargets.length)];
        let targetData = targetObj.userData.data;

        // UI
        const indicator = document.getElementById('processing-indicator');
        indicator.innerText = `GENERATING ${targetData.name.toUpperCase()}...`;
        gsap.to(indicator, { opacity: 1, duration: 0.5, yoyo: true, repeat: 3 });

        updatePanel({
            type: "GENERATIVE PROCESS",
            name: `${sourceData.name} ➔ ${targetData.name}`,
            desc: `Converting ${sourceData.name} into ${targetData.name} using latent space tokenization.`,
            color: targetData.color
        });

        // Beams
        const startPos = new THREE.Vector3();
        sourceObj.getWorldPosition(startPos);
        const centerPos = new THREE.Vector3(0, 0, 0);

        activeBeam.material.color.setHex(sourceData.color);
        activeBeam.material.opacity = 1;

        const tl = gsap.timeline({ onComplete: () => { isAnimating = false; activeBeam.material.opacity = 0; }});

        tl.to(sourceObj.scale, { x: 0.9, y: 0.9, z: 0.9, duration: 0.2, yoyo: true, repeat: 1 });

        const beamState = { prog: 0 };
        tl.to(beamState, { prog: 1, duration: 0.8, ease: "power2.in", onUpdate: () => {
            activeBeam.geometry.setFromPoints([startPos, new THREE.Vector3().lerpVectors(startPos, centerPos, beamState.prog)]);
        }});

        tl.to(earthWire.material, { opacity: 0.8, duration: 0.1, yoyo: true, repeat: 3 }); // Flash
        tl.add(() => { activeBeam.material.color.setHex(targetData.color); });

        const beamStateOut = { prog: 0 };
        tl.to(beamStateOut, { prog: 1, duration: 0.8, ease: "power2.out", onUpdate: () => {
            const targetPos = new THREE.Vector3();
            targetObj.getWorldPosition(targetPos);
            activeBeam.geometry.setFromPoints([centerPos, new THREE.Vector3().lerpVectors(centerPos, targetPos, beamStateOut.prog)]);
        }});

        tl.to(targetObj.scale, { x: 1.3, y: 1.3, z: 1.3, duration: 0.2, yoyo: true, repeat: 1 });
    }


    // --- ANIMATION LOOP ---
    const clock = new THREE.Clock();

    function animate() {
        requestAnimationFrame(animate);
        const delta = clock.getDelta();
        const elapsed = clock.getElapsedTime();

        // Note: OrbitControls handles interaction, we just update it
        controls.update();

        // Animations
        earthGroup.rotation.y += 0.03 * delta;
        plateGroup.rotation.y += 0.05 * delta;
        starField.rotation.y -= 0.01 * delta;

        // Billboarding Plates (Always face camera)
        plates.forEach(plate => {
            plate.position.y = Math.sin(elapsed * 1.5 + plate.userData.id) * 0.2;
            plate.lookAt(camera.position);
        });

        updateRaycaster();
        renderer.render(scene, camera);
    }

    // Handle Window Resize
    window.addEventListener('resize', () => {
        const w = container.clientWidth;
        const h = container.clientHeight;
        renderer.setSize(w, h);
        camera.aspect = w / h;
        camera.updateProjectionMatrix();
    });

    // Intro
    animate();
    gsap.from(camera.position, { y: 40, z: 40, duration: 3, ease: "power3.out" });

</script>
</body>
</html>
